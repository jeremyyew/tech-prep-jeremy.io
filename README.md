# TODO

## **Revision**

* [ ] **Mon 4th:** 1130-1230, 8-9pm
  * [x] Schedule
  * [ ] [https://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html](https://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html)
  * [ ] [https://github.com/jwasham/coding-interview-university/blob/master/README.md\#google-interview-university](https://github.com/jwasham/coding-interview-university/blob/master/README.md#google-interview-university)
  * [ ] Flashcards
  * [ ] Dynamic programming
* [ ] **Tues 5th:** 8am-10am
  * [ ] OOP Design patterns
  * [ ] Google Doc setup
  * [ ] Union find ****[**https://algs4.cs.princeton.edu/15uf/**](https://algs4.cs.princeton.edu/15uf/)
  * [ ] Segment trees/fenwick trees
  * [ ] Time complexity
* [ ] **Wed 6th:** 8am-9am, 11am-5pm
  * [ ] Djikstra's shortest path
  * [ ] Max flow
  * [ ] P/NP \(travelling salesman, knapsack\)
  * [ ] Graphs
    * [ ] DFS with adjacency list \(recursive\)
    * [ ] DFS with adjacency list \(iterative with stack\)
    * [ ] DFS with adjacency matrix \(recursive\)
    * [ ] DFS with adjacency matrix \(iterative with stack\)
    * [ ] BFS with adjacency list
    * [ ] BFS with adjacency matrix
    * [ ] single-source shortest path \(Dijkstra\)
    * [ ] minimum spanning tree
    * [ ] DFS-based algorithms \(see Aduni videos above\):
    * [ ] check for cycle \(needed for topological sort, since we'll check for cycle before starting\)
    * [ ] topological sort
    * [ ] count connected components in a graph
    * [ ]  list strongly connected components
    * [ ] check for bipartite graph
* [ ] **Thurs 7th:** 8am-10am
  * [ ] Two pointers/sliding window
  * [ ] OS - processes, threads, semaphores, mutexes, locks, context switching, scheduling
* [ ] **Fri 8th:** 8am-10am
  * [ ] Binary heaps, Linked List 
  * [ ] Tree traversal, bitmasks, binary search
* [ ] **Sat 9th**
  * [ ] Tries
  * [ ] \*\*\*\*
* [ ] **Sun 10th**
  * [ ] [https://google.github.io/styleguide/pyguide.html](https://google.github.io/styleguide/pyguide.html)

